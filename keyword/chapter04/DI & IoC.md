# DI & IoC

---

> DI와 IoC는 객체지향 프로그래밍에서 객체 간의 결합도를 줄이고 유연성을 높이기 위해 사용하는 핵심 개념이다.
>
- 이 두 가지 개념은 스프링에서 객체의 생성과 관리를 효율적으로 수행하기 위해 도입된다.

## ✅ IoC (Inversion of Control, 제어의 역전)

---

> IoC는 프로그램의 **제어 흐름을 개발자가 아닌 프레임워크가 관리**하도록 하는 개념이다.
>
- 즉, 객체의 생성, 의존 관계 설정, 생명 주기 관리 등의 제어 권한이 개발자가 아닌 외부 시스템으로 넘어간다.
- IoC 덕분에 개발자는 비즈니스 로직에 집중할 수 있으며, 객체 간의 결합도를 낮추고 코드 재사용성이 높아진다.
- 주로 스프링에서 IoC 컨테이너는 애플리케이션의 객체(빈)을 생성하고 관리하며, 각 객체가 의존하는 다른 객체를 주입하는 역할을 수행한다.

## ✅ DI (Dependency Injection, 의존성 주입)

---

> DI는 객체 간의 의존 관계를 내가 아닌 외부에서 대신 주입해주는 방법이다.
>
- 특정 객체가 자신이 의존하는 객체를 직접 생성하지 않고, 외부로부터 주입 받아 사용한다.
- DI를 통해 의존성을 분리할 수 있어서 테스트나 유지보수가 용이해진다.

### ✔️ 주입 방법

- **생성자 주입**: 객체 생성 시 생성자를 통해 의존성을 주입한다.
- **setter 주입**: 세터 메서드를 통해 의존성을 주입한다.
- **필드 주입**: 필드에 직접 주입한다.

## ✅ DI와 IoC의 관계

---

> IoC는 개념적 측면에서 **제어권을 프레임워크에 위임하는 것**을 의미하고,
DI는 IoC의 구체적인 구현 방식 중 하나이다.
>
- 즉, DI를 통해 **의존 관계를 프레임워크가 관리하며 주입해주는 방식**으로 IoC를 구현할 수 있다.

### ✔️ 예시

> Spring에서는 IoC와 DI를 통해 빈을 관리하며, `@Autowired` 어노테이션을 사용하여 의존성을 자동으로 주입해준다.
>

```java
@Component
public class Car {
    private Engine engine;

    // 생성자 주입 방식의 DI
    @Autowired
    public Car(Engine engine) {
        this.engine = engine;
    }

    // Car 클래스는 Engine에 의존하지만, 자신이 직접 생성하지 않고 외부에서 주입받습니다.
}

```

- `Car` 클래스는 `Engine` 클래스에 의존하지만, `Car`가 `Engine`을 직접 생성하지 않고, Spring 컨테이너가 `Engine` 객체를 생성하여 `Car`의 생성자에 주입해준다.

→ **IoC 컨테이너**가 제어권을 가지며 `Engine` 객체를 관리하고, 필요할 때 `Car`에 주입하는 방식으로 **IoC**와 **DI**가 함께 동작한다.