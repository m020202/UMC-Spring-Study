# N + 1 문제

---

> 요청이 **1개의 쿼리**로 처리되기를 기대했는데, **N개의 추가 쿼리가 발생**하는 상황
> 

-> **1 + N 문제**로 생각하는 것이 편하다❗

## ✅ @OneToMany에서 발생하는 1 + N 문제

---

> 1 + N 문제는 지연 로딩과 즉시 로딩에서 다 발생할 수 있다.
> 

<aside>
🔑

만약, 우리가 만든 엔티티에서 **Member** 객체와 연관된 **Review** 객체들을 조회하려고 할 때 몇 번의 쿼리가 발생할까❓

</aside>

🏛️ Member 엔티티 & Review 엔티티

```java
public class Member {
	// 생략
	@OneToMany(mappedBy = "member")
	private List<Review> reviewList = new ArrayList<>();
}

public class Review {
	// 생략
	@ManyToOne
	@JoinColumn(name = "member_id")
	private Member member;
}
```

### ✔️ 지연 로딩에서 발생하는 상황

---

❓**지연로딩이란**

- 엔티티 조회 시 일단 프록시(가짜) 객체를 가져다놓고, 실제로 해당 객체를 사용할 때 진짜 객체를 가져오도록 미루는 방식이다.

현재 Member 객체가 1개 그와 연관된 Review 객체가 총 N개가 있다고 생각하자.

그러면 지연 로딩에 의해 먼저 Member 객체 조회 시, 그와 연관된 Review 객체들은 당장 지금 사용할 것이 아니므로 다 프록시 객체로 가져올 것이다.
→ 이 때 **조회 쿼리 1번**

추가로 조회된 Member 객체의 reviewList에 있는 N개의 Review 엔티티 정보를 출력하려고 반복문을 돌면서 각 Review 엔티티를 조회할 때마다, 프록시 객체가 아닌 진짜 객체를 조회해야하기 때문에 1번씩 그러니까 총 N번의 추가 쿼리가 발생할 것이다.

→ 이 때 **조회 쿼리 N번**

이런 식으로 1 + N번의 불필요한 쿼리 문제가 발생할 수 있다❗

<aside>
🔑

그렇다면 **즉시 로딩**으로 처리하면 되지 않을까❓

</aside>

### ✔️ 즉시 로딩에서 발생하는 상황

---

**❓즉시 로딩이란**

- 지연 로딩과는 엔티티 조회 시 실제 객체를 가져오는 방식이다.

→ 1번의 쿼리로 실제 객체를 전부 가져오므로 1 + N 문제가 안 발생하지 않을까❓

<aside>
🔑

즉시 로딩 시에는 처음 쿼리를 만들 때 연관관계가 있는 엔티티는 신경 쓰지 않고 **조회 대상이 되는 엔티티 기준으로만** 쿼리를 만든다❗

</aside>

현재 Member 객체가 N개 그와 연관된 Review 객체가 각각 M개씩 있다고 생각하자.

그러면 먼저 Member 객체 조회 시, 한 번의 쿼리로 Member 객체 N개를 모두 가져올 것이다.

→ 이 때 **조회 쿼리 1번**

하지만, 이 때는 Member 객체만 가져왔지 각 Member 객체와 연관된 Review 객체들을 가져오지 않았기 때문에, N개의 Member 객체에 대해 각각 자신과 연관된 Review 객체를 모두 가져오는 쿼리를 한 번씩 더 날릴 것이다.

→ 이 때 **조회 쿼리 총 N번** (N * M번은 아님!!)

이런 식으로 1 + N 번의 불필요한 쿼리 문제가 발생할 수 있다❗

## ✅ 해결 방법 - Fetch Join

---

> 연관된 엔티티나 컬렉션을 **한 번에 같이 조회**하는 기능
> 

```java
@Query("select m from Member m left join fetch m.reviewList")
List<Review> findAllJPQLFetch();
```

- 최초에 관련된 데이터를 한꺼번에 가져와서 객체화 해줬기 때문에,
DB를 거치지 않고 데이터 꺼내서 반환해준다
    
    → 즉, 1개의 쿼리로 문제 해결❗
    

### ✔️ Fetch Join 문제 상황

---

> OneToMany 관계에서 **페이징 처리**를 할 떄 문제가 발생할 수 있다.
> 

![스크린샷 2024-11-05 오전 10.11.54.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/2e584bd0-e990-4776-81e5-a23114fbf6b5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-05_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.11.54.png)

- 위 사진처럼 페치 조인 사용 시, member 객체와 연관된 Review 객체들이 여러 개 존재할 수 있기 때문에, 이를 전부 가져오는 과정에서 **같은 Member 객체를 가진 레코드가 여러 개 발생할 수 있다.** → 정확한 페이징 처리가 불가능❗
- 따라서 JPA에서는 이를 방지하기 위해, 일단 조회되는 데이터를 전부 메모리에 보내고 **메모리에서 페이징 처리를 하도록** 수행한다.
    
    그렇기 때문에 메모리에 불필요한 데이터들도 전부 포함되기 때문에 메모리 낭비가 발생할 수 있다.
    

## ✅ 해결 방법 - @BatchSize

---

> 연관된 엔티티를 일정 개수씩 미리 로드하여 데이터베이스 쿼리 호출 횟수를 줄여주는 방식이다.
> 
- 페치 조인과 달리 한 번에 모든 데이터를 가져오는 대신, 필요한 데이터만 일괄로 가져와 성능을 최적화하는데 효과적이다.

### ✔️ 적용 예시

---

```java
@Entity
public class Member {
    @OneToMany(mappedBy = "member", fetch = FetchType.LAZY)
    @BatchSize(size = 10)
    private List<Review> reviewList = new ArrayList<>();
    
    // 생략
}

```

위 코드에서 `@BatchSize(size = 10)`을 사용하면, `reviewList`가 필요할 때마다 최대 10개의 `Review`를 한 번에 가져온다. 예를 들어, 100명의 `Member`에 대해 각 멤버의 `Review`를 조회하면, N개의 쿼리가 아니라 **100/10 = 10번의 쿼리**로 줄일 수 있다.

### ✔️`@BatchSize`의 작동 방식

---

- **일괄 로딩**: 필요한 연관 엔티티를 한 번에 조회하는 방식으로 작동한다. 예를 들어, `Member` 엔티티 10개가 있고 각 `Member`에 연관된 `Review`가 있다면, `@BatchSize(size = 10)`로 설정했을 때 **최대 10개의 `Member`에 대한 `Review`를 한 번에 조회하는 쿼리**가 발생한다.
- **지연 로딩과 호환**: `@BatchSize`는 지연 로딩과 함께 사용하여 필요한 순간에만 데이터를 로드하도록 최적화할 수 있다.

### ✔️ 한계

---

1. **일부 상황에서만 적용 가능**: 모든 경우에 `@BatchSize`가 적합한 것은 아니며, 배치 크기를 적절히 설정하지 않으면 성능 개선 효과가 미미할 수 있다.
2. **쿼리 복잡성 증가 가능**: 큰 데이터셋을 자주 로드하는 경우에는 페치 조인과 같은 방법이 더 효과적일 수 있다.