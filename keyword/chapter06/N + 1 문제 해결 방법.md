# N + 1 해결 방법

## ✅ Fetch Join

---

> 연관된 엔티티나 컬렉션을 **한 번에 같이 조회**하는 기능
>

```java
@Query("select m from Member m left join fetch m.reviewList")
List<Review> findAllJPQLFetch();
```

- 최초에 관련된 데이터를 한꺼번에 가져와서 객체화 해줬기 때문에,
  DB를 거치지 않고 데이터 꺼내서 반환해준다

  → 즉, 1개의 쿼리로 문제 해결❗


### ✔️ Fetch Join 문제 상황

---

> OneToMany 관계에서 **페이징 처리**를 할 떄 문제가 발생할 수 있다.
>

![스크린샷 2024-11-05 오전 10.11.54.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f1912130-0409-4e90-a90f-6091ae253e73/2e584bd0-e990-4776-81e5-a23114fbf6b5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-05_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.11.54.png)

- 위 사진처럼 페치 조인 사용 시, member 객체와 연관된 Review 객체들이 여러 개 존재할 수 있기 때문에, 이를 전부 가져오는 과정에서 **같은 Member 객체를 가진 레코드가 여러 개 발생할 수 있다.** → 정확한 페이징 처리가 불가능❗
- 따라서 JPA에서는 이를 방지하기 위해, 일단 조회되는 데이터를 전부 메모리에 보내고 **메모리에서 페이징 처리를 하도록** 수행한다.

  그렇기 때문에 메모리에 불필요한 데이터들도 전부 포함되기 때문에 메모리 낭비가 발생할 수 있다.


## ✅ @BatchSize

---

> 연관된 엔티티를 일정 개수씩 미리 로드하여 데이터베이스 쿼리 호출 횟수를 줄여주는 방식이다.
>
- 페치 조인과 달리 한 번에 모든 데이터를 가져오는 대신, 필요한 데이터만 일괄로 가져와 성능을 최적화하는데 효과적이다.

### ✔️ 적용 예시

---

```java
@Entity
public class Member {
    @OneToMany(mappedBy = "member", fetch = FetchType.LAZY)
    @BatchSize(size = 10)
    private List<Review> reviewList = new ArrayList<>();
    
    // 생략
}

```

위 코드에서 `@BatchSize(size = 10)`을 사용하면, `reviewList`가 필요할 때마다 최대 10개의 `Review`를 한 번에 가져온다. 예를 들어, 100명의 `Member`에 대해 각 멤버의 `Review`를 조회하면, N개의 쿼리가 아니라 **100/10 = 10번의 쿼리**로 줄일 수 있다.

### ✔️`@BatchSize`의 작동 방식

---

- **일괄 로딩**: 필요한 연관 엔티티를 한 번에 조회하는 방식으로 작동한다. 예를 들어, `Member` 엔티티 10개가 있고 각 `Member`에 연관된 `Review`가 있다면, `@BatchSize(size = 10)`로 설정했을 때 **최대 10개의 `Member`에 대한 `Review`를 한 번에 조회하는 쿼리**가 발생한다.
- **지연 로딩과 호환**: `@BatchSize`는 지연 로딩과 함께 사용하여 필요한 순간에만 데이터를 로드하도록 최적화할 수 있다.

### ✔️ 한계

---

1. **일부 상황에서만 적용 가능**: 모든 경우에 `@BatchSize`가 적합한 것은 아니며, 배치 크기를 적절히 설정하지 않으면 성능 개선 효과가 미미할 수 있다.
2. **쿼리 복잡성 증가 가능**: 큰 데이터셋을 자주 로드하는 경우에는 페치 조인과 같은 방법이 더 효과적일 수 있다.